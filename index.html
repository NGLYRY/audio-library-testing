<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title> Smart Fast-Forward Player </title>
  <style>
    body { background:#0e0e0e; color:#fff; font-family:sans-serif; text-align:center; margin-top:60px; }
    input[type="range"] { width:60%; margin-top:20px; }
    #keywordDisplay { margin-top:30px; font-size:1.6em; color:#ffd500; }
    #status { margin-top:20px; font-style:italic; }
  </style>
</head>
<body>
  <h1> Fast-Forward Audio Player</h1>

  <input type="file" id="audioFile" accept="audio/*"><br><br>


  <audio id="audio" controls src="mp3s/manwhothinks.mp3"></audio><br>
  <audio id="wordPlayer" style="display: none;" src="mp3s/manwhothinks.mp3"></audio><br>

  <label>Playback Speed:</label>
  <input type="range" id="speed" min="0.5" max="4" step="0.1" value="1">
  <span id="label">1.0x</span><br><br>
  <label>Semantic Threshold:</label>
  <input type="range" id="thresholdSlider" min="75" max="95" step="1" value="80">
  <span id="thresholdLabel">80th percentile</span><br><br>
  <label>Word Interval:</label>
  <input type="range" id="intervalSlider" min="0" max="1000" step="50" value="0">
  <span id="intervalLabel">0ms</span><br><br>
  <label>Word Playback Speed:</label>
  <input type="range" id="wordSpeedSlider" min="0.5" max="2" step="0.1" value="1">
  <span id="wordSpeedLabel">1.0x</span><br><br>
  <label>Overlap Sources:</label>
  <input type="range" id="overlapSourcesSlider" min="1" max="4" step="1" value="2">
  <span id="overlapSourcesLabel">2</span><br><br>
  
  <button id="pauseBtn" style="display:none; padding:10px 20px; font-size:16px; cursor:pointer;">Pause Smart Scrub</button>
  <div id="keywordDisplay"></div>

  <div id="status"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>
  <script>
    const API_KEY = "fae6aef01046408cb7e2c932adcf6e42"; 
    const uploadUrl = "https://api.assemblyai.com/v2/upload";
    const transcribeUrl = "https://api.assemblyai.com/v2/transcript";

    const audio = document.getElementById('audio');
    const wordPlayer = document.getElementById('wordPlayer');
    const slider = document.getElementById('speed');
    const label = document.getElementById('label');
    const display = document.getElementById('keywordDisplay');
    const status = document.getElementById('status');
    const fileInput = document.getElementById('audioFile');
    const pauseBtn = document.getElementById('pauseBtn');
    const thresholdSlider = document.getElementById('thresholdSlider');
    const thresholdLabel = document.getElementById('thresholdLabel');
    const intervalSlider = document.getElementById('intervalSlider');
    const intervalLabel = document.getElementById('intervalLabel');
    const wordSpeedSlider = document.getElementById('wordSpeedSlider');
    const wordSpeedLabel = document.getElementById('wordSpeedLabel');
    const overlapSourcesSlider = document.getElementById('overlapSourcesSlider');
    const overlapSourcesLabel = document.getElementById('overlapSourcesLabel');
    const PRE_ROLL_SEC = 0.05; // Pre-roll before word for context

    // Web Audio API setup for smooth transitions
    /*const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    const gainNode = audioContext.createGain();
    const source = audioContext.createMediaElementSource(audio);
    source.connect(gainNode);
    gainNode.connect(audioContext.destination);
    gainNode.gain.value = 1;*/

    let audioContext = null;
    let gainNode = null;
    let mediaSource = null;
    let wordPlayerGainNode = null;
    let wordPlayerMediaSource = null;
    // Pool for overlapped, pitch-preserving HTMLAudio word playback (avoids single-element seek pops)
    let wordPlayerPoolSize = 2;
    const wordPlayers = [];
    const wordPlayerGainNodes = [];
    const wordPlayerMediaSources = [];
    let wordPlayerPoolIndex = 0;
    
    function ensureWordPlayerPoolInitialized() {
      if (wordPlayers.length > 0) return;
      wordPlayers.push(wordPlayer);
    }

    function resizeWordPlayerPool(newSize) {
      const size = Math.max(1, Math.min(6, Math.floor(newSize || 1))); // clamp 1-6
      ensureWordPlayerPoolInitialized();

      // Add players if needed
      while (wordPlayers.length < size) {
        const i = wordPlayers.length;
        const clone = wordPlayer.cloneNode();
        clone.id = `wordPlayer_${i}`;
        clone.style.display = 'none';
        clone.preservesPitch = true;
        clone.mozPreservesPitch = true;
        clone.webkitPreservesPitch = true;
        document.body.appendChild(clone);
        wordPlayers.push(clone);
      }

      // Remove extra players (disconnect their nodes if exist)
      while (wordPlayers.length > size) {
        const removed = wordPlayers.pop();
        const g = wordPlayerGainNodes.pop();
        const m = wordPlayerMediaSources.pop();
        try { if (m) m.disconnect(); } catch {}
        try { if (g) g.disconnect(); } catch {}
        try { removed.remove(); } catch {}
      }

      wordPlayerPoolSize = size;
      wordPlayerPoolIndex = wordPlayerPoolIndex % wordPlayerPoolSize;

      // Rewire gain/media sources for any newly added players
      if (audioContext && wordPlayerGainNodes.length < wordPlayers.length) {
        for (let idx = wordPlayerGainNodes.length; idx < wordPlayers.length; idx++) {
          const p = wordPlayers[idx];
          const g = audioContext.createGain();
          const m = audioContext.createMediaElementSource(p);
          m.connect(g);
          g.connect(audioContext.destination);
          g.gain.value = 0;
          wordPlayerGainNodes[idx] = g;
          wordPlayerMediaSources[idx] = m;
        }
      }
    }

    function initAudioGraph() {
      if (audioContext) return; // Only run once
    
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      gainNode = audioContext.createGain();
      mediaSource = audioContext.createMediaElementSource(audio);
    
      mediaSource.connect(gainNode);
      gainNode.connect(audioContext.destination);
      gainNode.gain.value = 1;

      ensureWordPlayerPoolInitialized();
      resizeWordPlayerPool(wordPlayerPoolSize);
    }
    
    // Safari only allows AudioContext after user gesture
    document.addEventListener("click", () => {
      initAudioGraph();
      audioContext.resume();
    }, { once: true });

    // Set up hidden word player with full volume
    wordPlayer.volume = 1.0;
    wordPlayer.muted = false;
    // Preserve pitch on pooled players
    wordPlayer.preservesPitch = true;
    wordPlayer.mozPreservesPitch = true;
    wordPlayer.webkitPreservesPitch = true;

    // Smart-scrub playback via decoded buffer to avoid seek clicks
    let smartBuffer = null;                 // Decoded AudioBuffer of current track
    let smartSrc = null;                    // Current BufferSource for word playback
    let smartGain = null;                   // Gain node for word envelope
    let wordHowl = null;                    // Howler instance for click-free word playback
    let wordHowlUrl = null;                 // Object URL backing the Howler instance
    const MAX_OVERLAP_SOURCES = 3;          // Cap simultaneous overlapping word plays
    let activeWordHowlIds = [];             // Track active Howler play ids for overlap control

    async function decodeAudioFromBlob(blob) {
      try {
        const arrayBuffer = await blob.arrayBuffer();
        return await audioContext.decodeAudioData(arrayBuffer);
      } catch (e) {
        console.error('Failed to decode audio blob', e);
        return null;
      }
    }

    async function decodeAudioFromUrl(url) {
      try {
        const resp = await fetch(url);
        const blob = await resp.blob();
        return await decodeAudioFromBlob(blob);
      } catch (e) {
        console.error('Failed to decode from URL', url, e);
        return null;
      }
    }

    function stopSmartSegment(fadeMs = 10) {
      if (!smartSrc || !smartGain) return;
      const now = audioContext.currentTime;
      const fade = Math.max(0.005, (fadeMs || 10) / 1000);
      try {
        smartGain.gain.cancelScheduledValues(now);
        // Ramp to 0 then stop shortly after
        smartGain.gain.setValueAtTime(smartGain.gain.value, now);
        smartGain.gain.linearRampToValueAtTime(0, now + fade);
        setTimeout(() => {
          try { smartSrc.stop(); } catch {}
          try { smartSrc.disconnect(); } catch {}
          try { smartGain.disconnect(); } catch {}
          smartSrc = null;
          smartGain = null;
        }, fade * 1000 + 5);
      } catch {}
    }

    function playWordWithAudioElement(startSec, durationMs) {
      // Ensure audio context is initialized
      if (!audioContext || wordPlayerGainNodes.length === 0) {
        initAudioGraph();
        if (audioContext.state === 'suspended') {
          audioContext.resume();
        }
      }
      
      try {
        const idx = wordPlayerPoolIndex % wordPlayers.length;
        wordPlayerPoolIndex++;
        const player = wordPlayers[idx];
        const g = wordPlayerGainNodes[idx];

        // Scale fade times; keep a small minimum to avoid edge clicks
        const baseFadeMs = 240;
        const minFadeMs = 12;
        const fadeInMs = Math.max(minFadeMs, baseFadeMs / wordPlaybackSpeed);
        const fadeOutMs = Math.max(minFadeMs, baseFadeMs / wordPlaybackSpeed);
        const fadeIn = fadeInMs / 1000;
        const fadeOut = fadeOutMs / 1000;
        const now = audioContext.currentTime;

        // Reset and prep the chosen player
        g.gain.cancelScheduledValues(now);
        g.gain.setValueAtTime(0, now);
        player.preservesPitch = true;
        player.mozPreservesPitch = true;
        player.webkitPreservesPitch = true;
        player.playbackRate = wordPlaybackSpeed;

        // Seek while muted
        const seekTarget = Math.max(0, startSec); // no pre-roll to avoid mid-wave clicks
        player.pause();
        player.currentTime = seekTarget;

        // Compute durations
        const actualDurationMs = durationMs / wordPlaybackSpeed;
        const totalDurationMs = actualDurationMs + fadeInMs + fadeOutMs;

        // Play and envelope
        const playPromise = player.play();
        if (playPromise !== undefined) {
          playPromise.then(() => {
            const playNow = audioContext.currentTime;
            g.gain.cancelScheduledValues(playNow);
            g.gain.setValueAtTime(0, playNow);
            g.gain.linearRampToValueAtTime(1, playNow + fadeIn);

            const fadeStartTime = playNow + (actualDurationMs / 1000);
            g.gain.setValueAtTime(1, fadeStartTime);
            g.gain.linearRampToValueAtTime(0, fadeStartTime + fadeOut);
          }).catch(e => console.error('Failed to play word:', e));
        }

        // Stop after full duration including fades for this player only
        if (player._wordTimeout) clearTimeout(player._wordTimeout);
        player._wordTimeout = setTimeout(() => {
          try {
            player.pause();
            g.gain.cancelScheduledValues(audioContext.currentTime);
            g.gain.setValueAtTime(0, audioContext.currentTime);
          } catch {}
          player._wordTimeout = null;
        }, totalDurationMs + 10);
        
        return true;
      } catch (e) {
        console.error('Error playing word with audio element:', e);
        return false;
      }
    } 

    function playSmartSegment(startSec, durationMs) {
      // Prefer Howler-based playback to avoid clicks on seek
      if (playWordWithHowler(startSec, durationMs)) return true;
      // Fallback to audio element if Howler is unavailable
      return playWordWithAudioElement(startSec, durationMs);
    }

    function playWordWithHowler(startSec, durationMs) {
      if (!wordHowl || wordHowl.state() !== 'loaded') return false;

      try {
        const baseFadeMs = 180; // softer, short fades to minimize cuts
        const fadeMs = baseFadeMs / wordPlaybackSpeed;
        const actualDurationMs = durationMs / wordPlaybackSpeed;
        const seekTarget = Math.max(0, startSec - PRE_ROLL_SEC);

        const id = wordHowl.play();
        activeWordHowlIds.push(id);

        // Enforce overlap cap: if too many, fade+stop the oldest
        if (activeWordHowlIds.length > MAX_OVERLAP_SOURCES) {
          const oldestId = activeWordHowlIds.shift();
          try {
            wordHowl.fade(wordHowl.volume(oldestId), 0, fadeMs, oldestId);
            setTimeout(() => { try { wordHowl.stop(oldestId); } catch {} }, fadeMs + 20);
          } catch {}
        }

        wordHowl.rate(wordPlaybackSpeed, id);
        wordHowl.volume(0, id);
        wordHowl.seek(seekTarget, id);
        wordHowl.fade(0, 1, fadeMs, id);

        // Schedule fade out and stop, but allow overlap before fade starts
        setTimeout(() => {
          wordHowl.fade(1, 0, fadeMs, id);
        }, actualDurationMs);

        setTimeout(() => {
          try { wordHowl.stop(id); } catch {}
          activeWordHowlIds = activeWordHowlIds.filter(x => x !== id);
        }, actualDurationMs + fadeMs + 30);

        return true;
      } catch (e) {
        console.error('Howler playback error', e);
        activeWordHowlIds = activeWordHowlIds.filter(x => x !== id);
        return false;
      }
    }

  let informativeWords = [];
    let allTranscriptWords = [];  // Cache of full transcript for recalculating with different speeds
    let timer = null;
    let fastSpeed = 1;
    let nextIndex = 0;
    let isSmartScrubPaused = false;
    let manualThresholdPercentile = null; // User override for threshold
    let hasUserAdjustedThreshold = false; // Track if user manually set threshold
    let userIntervalMs = 0; // User override for word interval
    let wordPlaybackSpeed = 1.0; // Speed for individual word playback
    let speedTimeout; // Debounce timeout for speed slider
    let internalSeekGuard = false; // Guard to ignore programmatic seeks
    let wordPlayerTimeout = null; // Track timeout for stopping word player
    const WORD_OVERLAP_MS = 100; // Overlap between consecutive words for smooth transitions
    // Basic common words
    const commonWords = new Set(
      ["the","and","is","in","on","it","of","to","a","an","i","you","that","this",
      "he","she","they","we","for","with","as","at","by","from","but","or","not",
      "be","was","were","are","have","has","had","do","does","did","so","if","no",
      "yes","all","any","there","here","when","where","what","which","who","whom","why","how",
      "my","your","his","her","its","our","their","me","him","them","us","one","about",
      "like","just","more","some","out","up","down","now","then","also","than","too","very",
      "can","will","would","should","could","may","might","must", "go", "get", "got", "information"
      ]
    );

    // Pause button functionality
    pauseBtn.onclick = () => {
      if (isSmartScrubPaused) {
        // Resume
        isSmartScrubPaused = false;
        pauseBtn.textContent = "Pause Smart Scrub";
      } else {
        // Pause
        isSmartScrubPaused = true;
        pauseBtn.textContent = "Resume Smart Scrub";
        audio.pause();
        // Stop any currently playing smart segment to avoid tails/clicks
        stopSmartSegment(8);
        // Reset gain smoothly
        gainNode.gain.cancelScheduledValues(audioContext.currentTime);
        gainNode.gain.setValueAtTime(gainNode.gain.value, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(1, audioContext.currentTime + 0.01);
      }
    };

    // Shared function to load and process audio file
    async function loadAndProcessAudio(blob) {
      try {
        // Decode for smart-scrub playback
        smartBuffer = await decodeAudioFromBlob(blob);

        // Rebuild Howler instance for click-free seeking playback
        try {
          if (wordHowl) {
            wordHowl.unload();
            wordHowl = null;
          }
          if (wordHowlUrl) {
            URL.revokeObjectURL(wordHowlUrl);
            wordHowlUrl = null;
          }
          wordHowlUrl = URL.createObjectURL(blob);
          wordHowl = new Howl({
            src: [wordHowlUrl],
            html5: false, // use Web Audio for precise fades
            preload: true,
            onloaderror: (id, err) => console.error('Howler load error', err),
            onplayerror: (id, err) => console.error('Howler play error', err)
          });
          // Sync pooled HTML players to the same object URL for no-seek option
          ensureWordPlayerPoolInitialized();
          resizeWordPlayerPool(wordPlayerPoolSize);
          wordPlayers.forEach(p => { p.src = wordHowlUrl; });
        } catch (e) {
          console.error('Failed to init Howler for word playback', e);
        }
        
        status.textContent = "Uploading audio...";
        const audioUrl = await uploadToAssembly(blob);
        
        status.textContent = "Processing transcription...";
        const words = await getTranscript(audioUrl);
        
        // Display full transcript in console
        displayTranscriptInConsole(words);
        
        // Cache full transcript for recalculating with different speeds
        allTranscriptWords = words;
        
        informativeWords = selectInformativeWordsTFIDF(words, fastSpeed);
        nextIndex = 0;
        status.textContent = "Done! You can now play and scrub through keywords.";
        console.log("Informative words:", informativeWords);
      } catch (error) {
        console.error("Error processing audio:", error);
        status.textContent = "Error processing audio. Please try again.";
      }
    }

    // Load default file on startup
    window.addEventListener('load', async () => {
      const defaultFile = 'mp3s/manwhothinks.mp3';
      try {
        status.textContent = "Loading default audio...";
        const response = await fetch(defaultFile);
        const blob = await response.blob();
        await loadAndProcessAudio(blob);
      } catch (error) {
        console.error("Error loading default file:", error);
        status.textContent = "Default file loaded. Upload a file to transcribe.";
      }
    });

    fileInput.onchange = async () => {
      const file = fileInput.files[0];
      if (!file) return;
      audio.src = URL.createObjectURL(file);
      await loadAndProcessAudio(file);
    };

    async function uploadToAssembly(file) {
      const resp = await fetch(uploadUrl, {
        method: "POST",
        headers: { "Authorization": API_KEY },
        body: file
      });
      const data = await resp.json();
      return data.upload_url;
    }

    async function getTranscript(audioUrl) {
      const resp = await fetch(transcribeUrl, {
        method: "POST",
        headers: { "Authorization": API_KEY, "Content-Type": "application/json" },
        body: JSON.stringify({
          audio_url: audioUrl,
          speaker_labels: false,
          punctuate: true,
          format_text: true,
          word_boost: [],
          boost_param: "default",
          disfluencies: false
        })
      });
      const job = await resp.json();

      
      let statusCheck;
      do {
        await new Promise(r => setTimeout(r, 5000));
        const poll = await fetch(`${transcribeUrl}/${job.id}`, {
          headers: { "Authorization": API_KEY }
        });
        statusCheck = await poll.json();
        if (statusCheck.status === "error" || statusCheck.status === "failed") {
          throw new Error(statusCheck.error || "Transcription failed");
        }
      } while (statusCheck.status !== "completed");

      return statusCheck.words.map(w => ({ text: w.text, start: w.start / 1000, end: w.end ? w.end / 1000 : undefined }));
    }

    // Display transcript in browser console
    function displayTranscriptInConsole(words) {
      if (!words || words.length === 0) {
        console.warn('No words in transcript');
        return;
      }
      
      words.forEach((word, index) => {
        // word.start and word.end are already in seconds (converted in getTranscript)
        const startTime = word.start.toFixed(2);
        const endTime = word.end ? word.end.toFixed(2) : '?';
        const confidence = word.confidence ? `${(word.confidence * 100).toFixed(0)}%` : 'N/A';
        
        console.log(`[${startTime}s - ${endTime}s] ${word.text} (${confidence})`);
        
        // Add spacing every 10 words
        if ((index + 1) % 10 === 0) console.log('');
      });
      
      console.log('%câ”'.repeat(50), 'color: #ffd500');
      console.groupEnd();
    }

    // --- Length & Rarity-based word scoring ---
    function selectInformativeWordsTFIDF(words, speed = 1, overridePercentile = null) {
      if (!Array.isArray(words) || words.length === 0) return [];

      // Normalize tokens and filter basic noise
      const alpha = /[a-z]/i;
      const tokens = words.map(w => ({
        text: (w.text || '').toLowerCase().replace(/[^a-z'\-]/gi, ''),
        start: w.start,
        end: w.end
      })).filter(w => w.text && alpha.test(w.text) && !commonWords.has(w.text));

      if (tokens.length === 0) return [];

      // Count frequency of each word in transcript
      const wordFreq = new Map();
      for (const t of tokens) {
        wordFreq.set(t.text, (wordFreq.get(t.text) || 0) + 1);
      }

      // Calculate score for each unique word based on length and rarity
      // Score = word_length^2 / frequency
      // Longer words get exponentially higher weight, rarer words get higher weight
      const wordScores = new Map();
      for (const [word, freq] of wordFreq.entries()) {
        const length = word.length;
        const rarity = 1 / freq; // Inverse frequency (rarer = higher)
        const score = (length * length) * rarity; // Length squared times rarity factor
        wordScores.set(word, score);
      }

      // Build distribution of scores to set a dynamic threshold based on speed
      const scores = Array.from(wordScores.values()).filter(v => isFinite(v) && v > 0);
      if (scores.length === 0) return tokens; // fallback: return all tokens (already stopword-filtered)
      scores.sort((a, b) => a - b);
      
      // Dynamic percentile based on playback speed (unless overridden)
      // At 2.1x: 80th percentile (top 20% words - longer/rarer ones)
      // At 3x: ~85th percentile (top 15% words)
      // At 4x: ~92th percentile (top 8% words)
      let p = Math.min(0.95, 0.80 + (speed - 2.1) * 0.08);
      if (overridePercentile !== null && overridePercentile >= 0.60 && overridePercentile <= 0.95) {
        p = overridePercentile; // Use user's manual override
      }
      const idx = Math.floor(p * (scores.length - 1));
      const threshold = scores[idx];

      // Attach per-token score based on its word score; filter by threshold
      const informative = tokens
        .map(t => ({ ...t, score: wordScores.get(t.text) || 0 }))
        .filter(t => t.score >= threshold)
        .sort((a, b) => a.start - b.start);

      // Map back to expected shape { text, start } for existing logic
      return informative.map(({ text, start, end }) => ({ text, start, end }));
    }

   // Length & Rarity scoring --- END ---

    // Helper to recalculate informative words with current settings
    function recalcInformative(resetIndexToCurrent = true) {
      if (allTranscriptWords.length === 0) return;
      informativeWords = selectInformativeWordsTFIDF(
        allTranscriptWords,
        fastSpeed,
        hasUserAdjustedThreshold ? manualThresholdPercentile : null
      );
      if (resetIndexToCurrent) {
        realignNextIndexTo(audio.currentTime);
      }
    }

    function realignNextIndexTo(timeSec) {
      nextIndex = 0;
      while (nextIndex < informativeWords.length && informativeWords[nextIndex].start <= timeSec) {
        nextIndex++;
      }
    }

    // Update threshold slider UI based on speed (if user hasn't manually adjusted)
    function updateThresholdUIFromSpeed() {
      const dynamicP = Math.min(0.95, 0.80 + (fastSpeed - 2.1) * 0.08);
      thresholdSlider.value = Math.round(dynamicP * 100);
      thresholdLabel.textContent = `${Math.round(dynamicP * 100)}th percentile`;
    }

    // Speed slider - input event just updates UI, doesn't recalc queue
    slider.addEventListener('input', () => {
      const sp = parseFloat(slider.value);
      
      // Update UI immediately for smooth feedback
      label.textContent = sp.toFixed(1) + "x";
      fastSpeed = sp;
      
      // Update threshold slider to match speed
      updateThresholdUIFromSpeed();
      
      // If in smart scrub mode, preserve current position but don't recalc yet
      if (timer !== null && sp > 2) {
        speedChangeTime = audio.currentTime;
      }
    });
    
    // Handle when user releases the slider for immediate response on mode changes
    slider.addEventListener('change', () => {
      const sp = parseFloat(slider.value);
      
      fastSpeed = sp;
      label.textContent = sp.toFixed(1) + "x";
      updateThresholdUIFromSpeed();
      
      if (sp > 2) {
        // If not in smart scrub, recalc and start; if already in, recalc and realign
        if (timer !== null) {
          // Already in smart scrub, preserve position and realign queue
          speedChangeTime = audio.currentTime;
          recalcInformative(false);
          // Realign to next word after the preserved position
          nextIndex = 0;
          while (nextIndex < informativeWords.length && informativeWords[nextIndex].start <= speedChangeTime) {
            nextIndex++;
          }
        } else {
          recalcInformative(true);
          startSmartScrub();
        }
      } else {
        stopSmartScrub();
        audio.playbackRate = sp;
        audio.play().catch(() => {});
      }
    });

    // Semantic threshold slider handler
    thresholdSlider.oninput = () => {
      const val = parseInt(thresholdSlider.value, 10); // 50-95
      manualThresholdPercentile = val / 100;
      thresholdLabel.textContent = `${val}th percentile`;
      hasUserAdjustedThreshold = true;
      recalcInformative(false); // Recalc without resetting index
    };

    // Word interval slider handler
    intervalSlider.oninput = () => {
      const val = parseInt(intervalSlider.value, 10); // 0-1000ms
      userIntervalMs = val;
      intervalLabel.textContent = `${val}ms`;
    };

    // Word playback speed slider handler
    wordSpeedSlider.oninput = () => {
      const val = parseFloat(wordSpeedSlider.value); // 0.5-2.0
      wordPlaybackSpeed = val;
      wordSpeedLabel.textContent = `${val.toFixed(1)}x`;
    };

    // Overlap sources slider handler
    overlapSourcesSlider.oninput = () => {
      const val = Math.round(parseInt(overlapSourcesSlider.value, 10) || 1);
      overlapSourcesLabel.textContent = `${val}`;
      wordPlayerPoolSize = val;
      resizeWordPlayerPool(wordPlayerPoolSize);
      // Ensure sources are in sync after resizing
      if (wordHowlUrl) {
        wordPlayers.forEach(p => { p.src = wordHowlUrl; });
      }
    };

    // Store the actual playback position when speed changes
    let speedChangeTime = null;

    // Realign smart scrub index when user seeks via the progress bar
    audio.addEventListener('seeked', () => {
      // Ignore programmatic seeks from the scrubber itself
      if (internalSeekGuard) { internalSeekGuard = false; return; }

      const t = audio.currentTime;

      // If smart scrub is active, realign queue
      if (timer !== null) {
        stopSmartSegment(8);
        speedChangeTime = t;
        recalcInformative(false);
        realignNextIndexTo(speedChangeTime);
        return;
      }

      // If smart scrub is inactive but speed > 2, restart from the seeked position
      if (fastSpeed > 2 && informativeWords.length > 0) {
        recalcInformative(false);
        realignNextIndexTo(t);
        startSmartScrub();
      }
    });

    function startSmartScrub() {
      // Smart-scrub mode: play words at fixed time intervals (faster speed = shorter intervals)
      audio.pause();
      audio.playbackRate = 1.0;
      // Ensure audio context is initialized and running for buffer playback
      if (!audioContext) initAudioGraph();
      if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume().catch(()=>{});
      }
      pauseBtn.style.display = 'inline-block';
      isSmartScrubPaused = false;
      pauseBtn.textContent = "Pause Smart Scrub";

      // Calculate interval between words based on speed or user override
      // Base interval: 700ms at 2.1x, decreasing as speed increases
      // Formula: 700ms / (speed - 1.5) gives ~700ms at 2.1x, ~467ms at 3x, ~280ms at 4x
      const getIntervalMs = () => {
        if (userIntervalMs !== null) return userIntervalMs;
        return Math.max(0, 700 / Math.max(0.1, fastSpeed - 1.5));
      };
      
      // Calculate overlap based on word interval
      // At 0ms interval: full overlap (word starts before previous ends)
      // At higher intervals: less overlap
      const getOverlapMs = () => {
        const intervalMs = getIntervalMs();
        // Scale overlap from 100ms (at 0 interval) down to 0ms (at 500ms+ interval)
        return Math.max(0, WORD_OVERLAP_MS * (1 - intervalMs / 500));
      };
      
      let lastPlayTime = Date.now();

      timer = setInterval(() => {
        if (fastSpeed <= 2) return stopSmartScrub();
        if (isSmartScrubPaused) return;

        // Check if enough time has passed to play next word
        const now = Date.now();
        const gapMs = getIntervalMs(); // Gap between words (after word finishes)
        const overlapMs = getOverlapMs(); // Overlap to smooth transitions
        // Effective wait time = gap - overlap (overlap starts before previous word ends)
        const effectiveWaitMs = Math.max(0, gapMs - overlapMs);
        if (now - lastPlayTime < effectiveWaitMs) return;

        // Find next word
        if (nextIndex >= informativeWords.length) return stopSmartScrub();
        const next = informativeWords[nextIndex];

        // Use actual word duration from transcript (full duration)
        let wordDurationMs;
        if (typeof next.end === 'number' && next.end > next.start) {
          wordDurationMs = (next.end - next.start) * 1000; // Play full word duration
        } else {
          wordDurationMs = 250; // Fallback if no end timestamp
          console.warn(`Word "${next.text}" missing end timestamp, using ${wordDurationMs}ms`);
        }
        
        display.textContent = next.text;
        
        // Ensure we have a decoded buffer
        if (!smartBuffer && audio.src) {
          decodeAudioFromUrl(audio.src).then(buf => { smartBuffer = buf; });
          return; // Skip this cycle, try again next tick
        }
        
        // Update position (programmatic seek) and guard against triggering seek listeners
        try {
          internalSeekGuard = true;
          audio.currentTime = Math.max(0, next.start - PRE_ROLL_SEC);
        } catch {
          internalSeekGuard = false;
        }

        // Play the word - stopSmartSegment is called inside playSmartSegment
        const played = playSmartSegment(next.start, wordDurationMs);
        if (!played) {
          console.warn(`Failed to play word "${next.text}" at ${next.start.toFixed(2)}s`);
        }

        // Advance to next word and update last play time
        // Account for overlap: next word starts before current word fully ends
        nextIndex++;
        lastPlayTime = now + wordDurationMs + gapMs - overlapMs;
        
      }, 50); // Check every 50ms
    }

    function stopSmartScrub() {
      clearInterval(timer);
      timer = null;
      display.textContent = "";
      isSmartScrubPaused = false;
      // Stop any smart segment playback
      stopSmartSegment(8);
      // Reset gain to full volume smoothly
      gainNode.gain.cancelScheduledValues(audioContext.currentTime);
      gainNode.gain.setValueAtTime(gainNode.gain.value, audioContext.currentTime);
      gainNode.gain.linearRampToValueAtTime(1, audioContext.currentTime + 0.01);
      // Restore playback rate (don't auto-play here, let caller decide)
      audio.playbackRate = Math.max(0.5, Math.min(4, parseFloat(slider.value) || 1));
    }
  </script>
</body>
</html>

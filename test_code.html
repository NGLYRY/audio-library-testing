<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>High-Speed Scrubber — Smooth Word Dwell</title>
  <style>
    body { background:#0e0e0e; color:#fff; font-family:sans-serif; text-align:center; margin-top:40px; }
    input[type="range"] { width:60%; margin-top:12px; }
    #keywordDisplay { margin-top:18px; font-size:1.4em; color:#ffd500; min-height:1.4em; }
    #status { margin-top:12px; font-style:italic; color:#bbb; }
    label { display:block; margin-top:12px; }
    .controls { margin-top:6px; }
    .small { font-size:0.9em; color:#bbb; }
  </style>
</head>
<body>
  <h1>High-Speed Scrubber (word-aware)</h1>

  <input type="file" id="audioFile" accept="audio/*"><br><br>
  <audio id="audio" controls></audio><br>

  <label>Playback Speed: <span id="label">1.0x</span></label>
  <div class="controls">
    <input type="range" id="speed" min="0.5" max="4" step="0.1" value="1">
  </div>

  <label>Word Selection Threshold: <span id="thLabel">0.75</span></label>
  <div class="controls">
    <input type="range" id="tfidfThreshold" min="0" max="1" step="0.05" value="0.75">
    <div class="small">Higher = fewer highlighted words → faster scrub</div>
  </div>

  <div id="keywordDisplay"></div>
  <div id="status"></div>

  <script>
  /***********************
   * Configuration
   ***********************/
  const API_KEY = "fae6aef01046408cb7e2c932adcf6e42"; // replace as needed
  const uploadUrl = "https://api.assemblyai.com/v2/upload";
  const transcribeUrl = "https://api.assemblyai.com/v2/transcript";

  // audio / UI
  const audio = document.getElementById('audio');
  const fileInput = document.getElementById('audioFile');
  const slider = document.getElementById('speed');
  const label = document.getElementById('label');
  const display = document.getElementById('keywordDisplay');
  const status = document.getElementById('status');

  const tfidfSlider = document.getElementById('tfidfThreshold');
  const thLabel = document.getElementById('thLabel');

  // state
  let informativeWords = [];   // list of {text, start, end}
  window.__rawWords = null;    // keep original transcript for recalculation
  let timer = null;
  let dwellTimeout = null;
  let isDwelling = false;
  let nextIndex = 0;
  let fastSpeed = 1;
  let scrubLock = false;       // prevents overlapping async runs

  /***********************
   * Helpers: Upload & Transcribe
   ***********************/
  // initialize label
  thLabel.textContent = parseFloat(tfidfSlider.value).toFixed(2);

  fileInput.onchange = async () => {
    const file = fileInput.files[0];
    if (!file) return;
    audio.src = URL.createObjectURL(file);
    status.textContent = "Uploading audio...";
    try {
      const audioUrl = await uploadToAssembly(file);
      status.textContent = "Requesting transcription...";
      const words = await getTranscript(audioUrl);
      window.__rawWords = words; // store raw words for later recalculation
      informativeWords = selectInformativeWordsTFIDF(window.__rawWords);
      nextIndex = 0;
      status.textContent = "Ready — load complete.";
      console.log("informativeWords:", informativeWords);
    } catch (err) {
      console.error(err);
      status.textContent = "Transcription/upload error: " + (err.message || err);
    }
  };

  async function uploadToAssembly(file) {
    const resp = await fetch(uploadUrl, { method: "POST", headers: { "Authorization": API_KEY }, body: file });
    const data = await resp.json();
    if (!data.upload_url) throw new Error("Upload failed");
    return data.upload_url;
  }

  async function getTranscript(audioUrl) {
    const resp = await fetch(transcribeUrl, {
      method: "POST",
      headers: { "Authorization": API_KEY, "Content-Type": "application/json" },
      body: JSON.stringify({
        audio_url: audioUrl,
        speaker_labels: false,
        punctuate: true,
        format_text: true,
        word_boost: [],
        boost_param: "default",
        disfluencies: false
      })
    });
    const job = await resp.json();
    if (!job || !job.id) throw new Error("Transcription job failed to start");

    let statusCheck;
    do {
      await new Promise(r => setTimeout(r, 3000));
      const poll = await fetch(`${transcribeUrl}/${job.id}`, { headers: { "Authorization": API_KEY } });
      statusCheck = await poll.json();
      if (!statusCheck) throw new Error("Transcription poll failed");
      if (statusCheck.status === "error" || statusCheck.status === "failed") {
        throw new Error(statusCheck.error || "Transcription failed");
      }
    } while (statusCheck.status !== "completed");

    const words = Array.isArray(statusCheck.words) ? statusCheck.words : [];
    return words.map(w => ({
      text: w.text,
      start: (w.start || 0) / 1000,
      end: (typeof w.end === 'number') ? w.end / 1000 : undefined
    }));
  }

  /***********************
   * TF-IDF selection (user threshold)
   ***********************/
  function selectInformativeWordsTFIDF(words) {
    if (!Array.isArray(words) || words.length === 0) return [];
    const alpha = /[a-z]/i;

    const tokens = words.map(w => ({
      text: (w.text || '').toLowerCase().replace(/[^a-z'\-]/gi, ''),
      start: w.start,
      end: w.end
    })).filter(w => w.text && alpha.test(w.text) && !commonWords.has(w.text));

    if (tokens.length === 0) return [];

    const totalDuration = Math.max(...tokens.map(t => t.start));
    const windowSizeSec = 10;
    const numWindows = Math.max(1, Math.ceil((totalDuration + 0.0001) / windowSizeSec));

    const df = new Map(), tf = new Map();
    const windowSets = Array.from({ length: numWindows }, () => new Set());

    // populate tf and windowSets
    for (const t of tokens) {
      tf.set(t.text, (tf.get(t.text) || 0) + 1);
      const idx = Math.min(numWindows - 1, Math.floor(t.start / windowSizeSec));
      windowSets[idx].add(t.text);
    }
    for (const s of windowSets) for (const term of s) df.set(term, (df.get(term) || 0) + 1);

    const idf = new Map();
    for (const [term, dfCount] of df.entries()) {
      idf.set(term, Math.log((numWindows + 1) / (dfCount + 1)) + 1);
    }

    const tfidf = new Map();
    for (const [term, tfCount] of tf.entries()) {
      tfidf.set(term, tfCount * (idf.get(term) || 0));
    }

    const scores = Array.from(tfidf.values()).filter(v => isFinite(v) && v > 0);
    if (scores.length === 0) {
      // fallback: return tokens (already filtered for stopwords)
      return tokens.map(({ text, start, end }) => ({ text, start, end }));
    }

    scores.sort((a, b) => a - b);
    const userT = parseFloat(document.getElementById("tfidfThreshold").value || 0.75);
    const idx = Math.floor(userT * (scores.length - 1));
    const threshold = scores[Math.max(0, Math.min(scores.length - 1, idx))];

    return tokens
      .map(t => ({ ...t, score: tfidf.get(t.text) || 0 }))
      .filter(t => t.score >= threshold)
      .sort((a, b) => a.start - b.start)
      .map(({ text, start, end }) => ({ text, start, end }));
  }

  /***********************
   * UI: threshold slider
   ***********************/
  tfidfSlider.oninput = () => {
    thLabel.textContent = parseFloat(tfidfSlider.value).toFixed(2);
    if (window.__rawWords) {
      informativeWords = selectInformativeWordsTFIDF(window.__rawWords);
      nextIndex = 0;
      status.textContent = `Selected ${informativeWords.length} words (threshold ${thLabel.textContent})`;
    }
  };

  /***********************
   * Speed control & smart scrub
   ***********************/
  slider.oninput = () => {
    const sp = parseFloat(slider.value);
    label.textContent = sp.toFixed(1) + "x";
    fastSpeed = sp;
    if (sp > 2) {
      if (!timer) startSmartScrub();
    } else {
      stopSmartScrub();
      audio.playbackRate = sp;
    }
  };

  /***********************
   * Smooth seek helper (promises-based)
   ***********************/
  function smoothSeek(audioEl, targetTime, opts = {}) {
    const maxStep = opts.step || 0.03; // seconds per step
    const frameMs = opts.frameMs || 8;
    return new Promise(resolve => {
      const diff = targetTime - audioEl.currentTime;
      if (Math.abs(diff) < 0.04) {
        audioEl.currentTime = targetTime;
        return resolve();
      }
      const frames = Math.ceil(Math.abs(diff) / maxStep);
      let count = 0;
      const step = diff / frames;
      const iv = setInterval(() => {
        count++;
        audioEl.currentTime = Math.min(Math.max(0, audioEl.currentTime + step), audioEl.duration || Infinity);
        if (count >= frames) {
          clearInterval(iv);
          audioEl.currentTime = targetTime;
          resolve();
        }
      }, frameMs);
    });
  }

  /***********************
   * Fade helpers (200ms default) — restore prior volume after fade out
   ***********************/
  function fadeInAudio(audioEl, durationMs = 200) {
    try { audioEl.volume = 0; } catch { audioEl.volume = 1; }
    const steps = 20;
    const stepTime = Math.max(6, durationMs / steps);
    let v = 0;
    const ramp = setInterval(() => {
      v += 1 / steps;
      if (v >= 1) {
        audioEl.volume = 1;
        clearInterval(ramp);
      } else {
        audioEl.volume = Math.max(0, Math.min(1, v));
      }
    }, stepTime);
  }

  function fadeOutAudio(audioEl, durationMs = 200, callback = () => {}) {
    const originalVol = Math.max(0, Math.min(1, audioEl.volume || 1));
    const steps = 20;
    const stepTime = Math.max(6, durationMs / steps);
    let v = originalVol;
    const ramp = setInterval(() => {
      v -= originalVol / steps;
      if (v <= 0) {
        clearInterval(ramp);
        audioEl.volume = originalVol; // restore for next time
        callback();
      } else {
        audioEl.volume = Math.max(0, Math.min(originalVol, v));
      }
    }, stepTime);
  }

    
  async function startSmartScrub() {
    // Pause regular playback and enforce playbackRate = 1 while dwelling
    audio.pause();
    audio.playbackRate = 1.0;

    if (!informativeWords || informativeWords.length === 0) {
      status.textContent = "No informative words selected.";
      return;
    }

    // timer tick drives the scrubbing loop; guard with scrubLock to avoid overlap
    timer = setInterval(async () => {
      if (fastSpeed <= 2) return stopSmartScrub();
      if (isDwelling || scrubLock) return;
      scrubLock = true;

      try {
        // Advance nextIndex to first informative word strictly after currentTime
        while (nextIndex < informativeWords.length && informativeWords[nextIndex].start <= audio.currentTime + 0.01) {
          nextIndex++;
        }
        if (nextIndex >= informativeWords.length) {
          return stopSmartScrub();
        }

        const next = informativeWords[nextIndex];

        // Compute start earlier and extended tail
        const earlyMs = 200;
        const lateMs = 200;
        const earlyStart = Math.max(0, (next.start || 0) - earlyMs / 1000);

        // Smooth seek to earlyStart to avoid clicks
        await smoothSeek(audio, earlyStart);

        // Compute dwell: play length covering the word body + extensions
        let dwellMs;
        if (typeof next.end === 'number' && next.end > next.start) {
          const durMs = (next.end - next.start) * 1000;
          dwellMs = Math.max(80, Math.min(2000, durMs));
        } else {
          dwellMs = Math.max(80, 1200 / Math.max(0.1, fastSpeed));
        }

        const finalDwell = dwellMs + earlyMs + lateMs;

        // Start dwelling: play at normal rate with fade-in
        isDwelling = true;
        displayWord(next.text);

        // Ensure we allow the browser to settle after seek
        await new Promise(r => setTimeout(r, 8));
        audio.playbackRate = 1.0;
        audio.play().catch(() => { /* ignore autoplay restrictions */ });

        // fade in over earlyMs or finalDwell if shorter
        fadeInAudio(audio, Math.min(200, finalDwell));

        // schedule end-of-dwell: fade out then pause and advance
        clearTimeout(dwellTimeout);
        dwellTimeout = setTimeout(() => {
          fadeOutAudio(audio, Math.min(200, Math.max(80, finalDwell / 3)), () => {
            try { audio.pause(); } catch(e) {}
            isDwelling = false;
            nextIndex++;
          });
        }, Math.max(80, finalDwell));

      } catch (err) {
        console.error("scrub tick error", err);
      } finally {
        scrubLock = false;
      }
    }, Math.max(40, 1000 / Math.max(0.1, parseFloat(slider.value) || 1)));
  }

  function stopSmartScrub() {
    if (timer) clearInterval(timer);
    timer = null;
    if (dwellTimeout) clearTimeout(dwellTimeout);
    dwellTimeout = null;
    isDwelling = false;
    scrubLock = false;
    display.textContent = "";
    audio.playbackRate = Math.max(0.5, Math.min(4, parseFloat(slider.value) || 1));
  }

  function displayWord(w) {
    display.textContent = w || "";
  }

  // Expose manual recalculation (useful if user changes threshold after transcript)
  window.recalcWords = () => {
    if (window.__rawWords) {
      informativeWords = selectInformativeWordsTFIDF(window.__rawWords);
      nextIndex = 0;
      status.textContent = `Selected ${informativeWords.length} words.`;
    }
  };

  // small safety: stop scrub if user manually plays audio
  audio.addEventListener('play', () => {
    if (fastSpeed > 2) {
      stopSmartScrub();
    }
  });

  // stop scrub when audio ends
  audio.addEventListener('ended', () => stopSmartScrub());

  </script>
</body>
</html>
